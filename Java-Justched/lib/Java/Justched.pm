package Java::Justched;
use strict;
use warnings;
use Linux::Info::SysInfo 0.6;
use Template 2.24;
use Archive::Tar::Wrapper 0.18;
use Config::IniFiles 2.82;
use File::Spec;
use DateTime 1.06;
use Cwd;
use Config;
use Exporter 'import';

=pod

=head1 NAME

Java::Jusched - core functions for justched script

=head1 SYNOPSIS

    use Java::Justched qw(:all);

=head1 DESCRIPTION

Unless you're a developer, you're probably looking for the justched Perl script. Check it's online help.

Otherwise, here you will find information about all subs used by the justched to do what is supposed to do. Those subs are really specific, not generic, but
since you're a developer I understand that you know what you're doing.

=head1 EXPORTS

The tag C<all> will export the subs C<check_tar>, C<gen_paths>, C<gen_date>, C<gen_scripts>, C<get_remove_jvm>, C<get_local_jvm> and C<check_arch>.

=cut

our %EXPORT_TAGS = (
    all => [
        qw(check_tar gen_paths gen_date gen_scripts get_remote_jvm get_local_jvm check_arch)
    ]
);

=pod

=head1 SUBS

=head2 check_tar

Retrieves the directory name that will be unpacked from Java tarball. This will be used in the DEB package creation.

Expects as parameter the tarball of JVM as released by Oracle.

The same information could have be created using C<version> and C<update> information, but it wouldn't be a robust schema.

=cut

sub check_tar {

    my $tar_file = shift;
    my $tar      = Archive::Tar::Wrapper->new();
    $tar->read($tar_file);
    my $parent_dir;
    $tar->list_reset();
    foreach ( my $entry = $tar->list_next ) {
        if ( $entry->[2] eq 'f' ) {
            my @list = File::Spec->splitdir( $entry->[0] );
            $parent_dir = $list[0];
            last;
        }
    }

    return $parent_dir;

}

=head2 gen_paths

Generate complete paths for a DEB maintainer script that will be dinamically generated.

It expects as parameter the maintainer script name and a reference to a L<Config::IniFiles> class instance.

Returns the complete paths to the source maintainer script and the result script respectively.

=cut

sub gen_paths {

    my ( $script, $cfg ) = @_;

    return (
        File::Spec->catfile( 'etc', 'default', 'justched', 'templates', $script ),
        File::Spec->catfile( $cfg->val( 'basic', 'repository' ), $script )
    );

}

=head2 gen_date

Returns a data string as expected Debian Changelog format.

=cut

sub gen_date {

    my $now = DateTime->now();
    return $now->strftime("%a, %d %b %Y %T %z");

}

=head2 gen_scripts

Generates the maintainer scripts automatically by using templates.

The templates are expected to be located in C</etc/default/justched/templates> directory.

The location of the result files generated by those templates is defined in the INI file located at C</etc/default/justched/config.ini> file.

Expects as parameter a hash reference with JVM information, a instance of L<Config::IniFiles> pointing to the default configuration file and the application version respectively.

=cut

sub gen_scripts {

    my ( $jvm_ref, $cfg, $version ) = @_;
    my $tt = Template->new( ABSOLUTE => 1 );
    my $jvm_dir = check_tar( $jvm_ref->{filename} );

    my $jre_version = $jvm_ref->{version} . 'u' . $jvm_ref->{update};

    my ( $template, $result ) =
      gen_paths( 'oracle-java8-installer.postinst', $cfg );
    $tt->process(
        $template,
        {
            j_install_dir  => $cfg->val( 'basic', 'j_install_dir' ),
            cache_dir      => $cfg->val( 'basic', 'cache_dir' ),
            unpack_dir     => $cfg->val( 'basic', 'unpack_dir' ),
            jinfo          => $cfg->val( 'basic', 'jinfo' ),
            script_version => $version,
            jre_version    => $jre_version,
            j_dir          => $jvm_dir,
            filename       => $jvm_ref->{filename}
        },
        $result
    ) or die $tt->error;

    my $curr_date = gen_date();

    ( $template, $result ) = gen_paths( 'copyright', $cfg );
    $tt->process(
        $template,
        {
            maintainer  => $cfg->val( 'basic', 'maintainer' ),
            maint_email => $cfg->val( 'basic', 'maint_email' ),
            curr_date   => $curr_date
        },
        $result
    ) or die $tt->error;

    ( $template, $result ) = gen_paths( 'changelog', $cfg );
    $tt->process(
        $template,
        {
            maintainer  => $cfg->val( 'basic', 'maintainer' ),
            maint_email => $cfg->val( 'basic', 'maint_email' ),
            curr_date   => $curr_date,
            jre_version => $jre_version
        },
        $result
    ) or die $tt->error;

    ( $template, $result ) = gen_paths( 'control', $cfg );
    $tt->process( $template,
        { maintainer => $cfg->val( 'basic', 'maintainer' ) }, $result )
      or die $tt->error;

    ( $template, $result ) = gen_paths( 'oracle-java8-installer.config', $cfg );
    $tt->process(
        $template,
        {
            script_version => $version,
            j_install_dir  => $cfg->val( 'basic', 'j_install_dir' )
        },
        $result
    ) or die $tt->error;

    ( $template, $result ) = gen_paths( 'oracle-java8-installer.dirs', $cfg );
    $tt->process(
        $template,
        {
            cache_dir     => $cfg->val( 'basic', 'cache_dir' ),
            j_install_dir => $cfg->val( 'basic', 'j_install_dir' )
        },
        $result
    ) or die $tt->error;

    ( $template, $result ) = gen_paths( 'oracle-java8-installer.postrm', $cfg );
    $tt->process(
        $template,
        {
            cache_dir     => $cfg->val( 'basic', 'cache_dir' ),
            j_install_dir => $cfg->val( 'basic', 'j_install_dir' ),
            jinfo         => $cfg->val( 'basic', 'jinfo' ),
            unpack_dir    => $cfg->val( 'basic', 'unpack_dir' )
        },
        $result
    ) or die $tt->error;

    exit 0;

}

=head2 get_remove_jvm

Checks remotely the lastest JVM available for download for Linux (32 and 64 bits).

Expects as parameter a L<WWW::Mechanize> instance and the URL to check the JVM downloads.

Returns a hash reference with the keys C<version> and C<update> with their respective values recovered.

=cut

sub get_remote_jvm {

    my ( $mech, $url ) = @_;
    $mech->get($url);
    my $first = scalar( $mech->find('h4') );

    my $info;
    foreach my $row ( $first->content_list ) {
        $row =~ s/^\s+//;
        if ( $row =~ /^Version/ ) {
            $row =~ s/\s+$//;
            $info = $row;
            last;
        }
    }

    #Version 8 Update 73
    my @parts = split( /\s/, $info );
    my %info = ( version => $parts[1], update => $parts[3] );

    #validations
    foreach my $key (qw(version update)) {

        unless ( exists( $info{$key} ) and ( defined( $info{$key} ) ) ) {
            warn "Missing information about $key, please check HTML from $url";
            return undef;
        }

    }

    return \%info;

}

=head2 get_local_jvm

Recovers information from the local installed JVM (if available).

Returns a hash reference with the keys C<version>, C<platform>, C<jvm_vendor> and C<update>.

JVM availability is checked by issuing a C<which> program in the shell. If available, a custom Java class will
be executed and information from the JVM will be provided to STDOUT, which output will be read and parsed.

This Java class is expected to be in the same location as the C<justched> script. The source code of it (not impressive by any means)
is also available, if you're especially paranoic.

If you're just a bit paranoic, the class SHA256sum output follows below:

    146a512f89f6025b92cc0ad7146479d33a2f03f5ed426d40c805d81ebdf7ad28b2067857e9bbe4dd8efefd70172535024a464a47702f323228116275eed65a88  JvmDetails.class

=cut

sub get_local_jvm {

    my $jvm = `which java`;
    chomp($jvm);
    if ( defined($jvm) ) {

        my $java_class = File::Spec->catfile( $Config{sitebin}, 'JvmDetails' );
        my $cmd        = "$jvm $java_class";
        my $details    = `$cmd`;
        my @parts      = split( /\n/, $details );
        my @version_numbers = split( /\./, $parts[0] );
        my %details         = (
            version    => $version_numbers[1],
            update     => ( split( '_', $version_numbers[2] ) )[1],
            platform   => $parts[1],
            jvm_vendor => $parts[2]
        );
        return \%details;

    }
    else {

        return undef;

    }

}

sub check_arch {
    my $local_jvm = shift;

    my $linux_info = Linux::Info::SysInfo->new();
    my $arch       = $linux_info->get_proc_arch;

    if ( defined($local_jvm) ) {
        if ( $local_jvm->{platform} != $arch ) {
            warn 'local JVM is '
              . $local_jvm->{platform}
              . " but the processor architecture is $arch";
        }

        return $local_jvm->{platform};
    }
    else {
        return $arch;
    }

}

1;
